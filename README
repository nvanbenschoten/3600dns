 ____    __   ___   ___      _           
|___ \  / /  / _ \ / _ \    | |          
  __) |/ /_ | | | | | | | __| |_ __  ___ 
 |__ <| '_ \| | | | | | |/ _` | '_ \/ __|
 ___) | (_) | |_| | |_| | (_| | | | \__ \
|____/ \___/ \___/ \___/ \__,_|_| |_|___/

--- Team America ---

Nathaniel Dempkowski and Nathan VanBenschoten

----------------------
 High Level Approach
----------------------

<<<<<<< HEAD
We have chosen to implement the inode-based file system layout.

At a high level, the disk is divided into the following seven different types of blocks:

- BLOCKS

Volume Control (VCB)
The VCB is the first block in the file system, and contains metadata about the entire disk and the location of the root directory. The location of the first FREE block is also stored in the VCB.

Directory Node (DNODE)
DNODE blocks denote a directory, and as a result there is one per directory, which contains metadata about the directory as well as pointers to the DIRENT blocks that actually contain directory entries.

Directory Entry (DIRENT)
DIRENT blocks contain the contents of directories, which is generally the name, type, and block number of each entry, along with the validity of that entry. 

File Node (INODE)
INODE blocks represent files, and thus contain metadata about the file including, size, user ID of the owner, group ID of the owner, and the permissions associated with the file.

Indirect (INDIRECT)
INDIRECT blocks store pointers to either DIRENT blocks or INDIRECT blocks. They are used to efficiently store additional information about directories as needed.

Data (DB)
DB blocks contain raw user data, and nothing else.

Free (FREE)
FREE blocks are blocks that can be used as necessary by the file system, which also store information abount the next free block as a singly linked list.

Upon the initial format of the disk, we create a VCB as block 0, a DNODE as block 1, a DIRENT as block 2, and FREE blocks as blocks 3-N. Anywhere a block number is stored, we also store the validity of that number, which serves as an efficient check for things like free space, and some directory entries. 

We chose to implement the inode-based file system layout because we felt that it was a more elegant and interesting design, and were willing to put in the extra effort that goes along with that. It also more closely mirrors modern file system layouts, and we felt there was more to be learned from implementing it.

We implement almost all of the core functionality that an end user would expect in our file system. Our disk is mountable and unmountable. Once the disk is mounted files and directories can be created, renamed, and deleted. We support metadata for files and directories like permissions, owners, and create, access, and modify times. We can read, write, and truncate the data for these files. Directories can be read, and we also support recursive directories as a usable filesystem should. Linux utilities like ls, cat, rm, touch, etc. generally work with our filesystem as expected.

- Helper Functions

parseInputFlags
This function parses the input flags if one is passed in. It does this by comparing the flag string to the known valid flags. It will return an error if the flag is not valid. The function is called if there are more than 2 arguments passed into the program, indicating the use of an optional flag.

parseInputServer
This function divides the server/port string into its corresponding data. If first strips off the @ from the front of the string, then iterates through it until it finds a ':' signifying the specification of a non-defualt port. If this non default port, the part of the string after the port is converted to a short and put in the place of port.

parseLabel
This function recursively parses labels into their corresponding string. It does this by taking in the packet, the labels beginning offset in the label, and the name buffer where the label is to be placed. It first checks the first two bits of the label to determine if the label is a pointer or a normal label. Next, depending on if the label is a pointer or a normal label, it handles parsing it into a string. If the label contains the actual data, the bytes are interated through and added to the string, making sure to add the '.' where they belong. If the label is a pointer, the data is read out as the new offset, and the fucntion is called recursively on this offset.

----------------------
 Challenges Faced
----------------------

We faced a number of challenges when creating our DNS Client. The first was handling endianness differences between the network and our system. Because all network data was stored in a big endian format and all system data was stored in a little endian format, we had to be very careful when interpreting multiple-byte data. This challenge was faced by using functions from c's inet library called htons, htonl, ntohs, and ntohl. These functions translated data to the correct endianness, allowing it to correctly interpretted. We used these functions whenever dealing with multi-byte data in our program.

Antoher challenge faced in the development of our system was handling DNS packet compression. In order to reduce the size of a message, domain systems utilize a compression scheme wherein they replace duplicated domain names in the NAME, QNAME, and RDATA with pointers to the prior occurrence of the same name. The solution to this problem was to recursively handle label parsing. We did this in our parseLabel function, where we set the passed in offset to the value of the offset if a pointer was found while parsing a label.

----------------------
 Properties/Features
----------------------

We made a fully featured Inode based file system. This system allows for mounting, unmounting, getting attributes, creating files, reading from files, writing to files, truncating files, deleting files, reading a directory, creating a directory, changing the owner, group, and mode of a file, and updating metadata times. All of these API calls allowed for a well functioning file system which has all the features users expect from a file system.  

For extra credit, we implemented the ability to create and traverse multiple directories. This provided the challenge of both writing the mkdir function and making our findDNODE search recursively over dnodes. By making findDNODE recursive, we were able to accurately locate the current dnode no matter how deep in the directory structure it was located. Once this was implemented, our file system was truly usable. 

To cut down on the level of our disk reads, which take incredibly more time than memory reads, we implemented a 50KB cache (512 B/block * 100 blocks). Because we had already abstracted disk reads and writes away into our bufdread and bufdwrite functions (which allowed for unified error checking and buffered reading and writing), adding in a cache was simple. To do this, we created the cache memory itself, and two arrays with elements corresponding to blocks entries in the cache. The first array held the blockNums for each of the block entries in the cache. The second held the priority of each entry in the cache, allowing us to implement an effective LRU cache. When comparing the cache performance to the uncached performance, in one test where we created 100 files and read the directory three times, we found a drop from 192,566 reads from disk when uncached to only 109 reads. This huge improvement proved we had succeeded with our cache. 

If a disk was not unmounted safely upon its last use, we perform an integrity check at mount. This consists of cataloging free blocks and blocks we know are in use on the disk. We then look for contradictions in those lists and blocks that have not been cataloged and add those to the free list, updating file and directory nodes as necessary. This returns the disk to a usable state for the end user, though some data may be lost depending on when the disk was unmounted. This is important because otherwise our entire disk would be useless if it was not safely unmounted.

----------------------
 Testing Procedure
----------------------

We based our testing on the provided test, as well as using the debug functions like dump_packet and the linux command dig to make sure we were always sending and interpreting packets correctly. During these tests we heavily used GDB to debug edge cases that we thought of and saw. Additionally, we made a few smaller testing programs to verify that our helper functions functioned correctly in all cases, allowing us to pinpoint errors that may have gone undetected otherwise. Throughout development we also modified the provided test to allow us to automatically test various specific cases. Additionally, we integrated git into our workflow as it provided a convenient tool for our workflow. In total we had ~65 commits. 

----------------------
 Bald Eagle
----------------------

                               /T /I
                              / |/ | .-~/
                          T\ Y  I  |/  /  _
         /T               | \I  |  I  Y.-~/
        I l   /I       T\ |  |  l  |  T  /
     T\ |  \ Y l  /T   | \I  l   \ `  l Y
 __  | \l   \l  \I l __l  l   \   `  _. |
 \ ~-l  `\   `\  \  \\ ~\  \   `. .-~   |
  \   ~-. "-.  `  \  ^._ ^. "-.  /  \   |
.--~-._  ~-  `  _  ~-_.-"-." ._ /._ ." ./
 >--.  ~-.   ._  ~>-"    "\\   7   7   ]
^.___~"--._    ~-{  .-~ .  `\ Y . /    |
 <__ ~"-.  ~       /_/   \   \I  Y   : |
   ^-.__           ~(_/   \   >._:   | l______
       ^--.,___.-~"  /_/   !  `-.~"--l_ /     ~"-.
              (_/ .  ~(   /'     "~"--,Y   -=b-. _)
               (_/ .  \  :           / l      c"~o \
                \ /    `.    .     .^   \_.-~"~--.  )
                 (_/ .   `  /     /       !       )/
                  / / _.   '.   .':      /        '
                  ~(_/ .   /    _  `  .-<_
                    /_/ . ' .-~" `.  / \  \          ,z=.
                    ~( /   '  :   | K   "-.~-.______//
                      "-,.    l   I/ \_    __{--->._(==.
                       //(     \  <    ~"~"     //
                      /' /\     \  \     ,v=.  ((
                    .^. / /\     "  }__ //===-  `
                   / / ' '  "-.,__ {---(==-
                 .^ '       :  T  ~"   ll      
                / .  .  . : | :!        \\			- Team America
               (_/  /   | | j-"          ~^
                 ~-<_(_.^-~"

			(Shamelessly stolen from the internet)
